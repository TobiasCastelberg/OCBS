# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' EvalStatSlow
#' @description This function is slow and should be avoided. Evaluates the gain function (test statistic)
#' \code{optimization = "L2"} will compute the cumulative sums just for this evaluation.
#' \code{optimization = "L1"} will create a tree just for this evaluation.
#' @param X data matrix
#' @param s first change point
#' @param t second change point
#' @param optimization \code{"L1"} or \code{"L2"} loss
#' @return gain/reduction of loss/test statistic for this setup of \code{s} and \code{t}
#' @export
#'
EvalStatSlow <- function(X, s, t, optimization = "L2") {
    .Call(`_OCBS_EvalStatSlow`, X, s, t, optimization)
}

#' Maximal CBS statistic
#'
#' @description Find the points \code{s,t} so that the loss is reduced most when
#' splitting the segment in \eqn{X_1,...,X_s,X_{t+1},...,X_T} and \eqn{X_{s+1},...,X_t}.
#'
#' @param X data matrix
#' @param optimization minimization of \code{L1} or \code{L2} loss
#' @param method chose between the fast \code{advanced} or the complete \code{full} search
#' @param circular performs binary segmentation if \code{FALSE}. In that case
#' will return \code{s=0}
#' @param min_seg minimal segment length. Note that change points still can be closer together than \code{min_seg}
#' @return list containing the best change point candidates \code{shift}(\eqn{s}) and \code{ind}(\eqn{t}) and the
#' the corresponding gain \code{stat}
#' @export
MaxStats <- function(X, optimization = "L2", method = "advanced", circular = TRUE, min_seg = 2L) {
    .Call(`_OCBS_MaxStats`, X, optimization, method, circular, min_seg)
}

#' Maximal CBS statistic
#'
#' @description Find the points \code{s,t} so that the loss is reduced most when
#' splitting the segment in \eqn{X_1,...,X_s,X_{t+1},...,X_T} and \eqn{X_{s+1},...,X_t}.
#'
#' @param X data matrix
#' @param boundary stopping boundary for early stopping
#' @param cand_stat candidate stat, that is, the value from
#' @param optimization minimization of \code{L1} or \code{L2} loss
#' @param method chose between the fast \code{advanced} or the complete \code{full} search
#' @param nr_perms maximal number of permutations
#' @param alpha significance level
#' @param circular performs binary segmentation if \code{FALSE}. In that case
#' will return \code{s=0}
#' @param min_seg minimal segment length. Note that change points still can be closer together than \code{min_seg}
#' @return list containing the best change point candidates \code{shift}(\eqn{s}) and \code{ind}(\eqn{t}) and the
#' the corresponding gain \code{stat}
#' @export
PermTest <- function(X, boundary, cand_stat, optimization, method, alpha, nr_perms = 10000L, circular = TRUE, min_seg = 2L) {
    .Call(`_OCBS_PermTest`, X, boundary, cand_stat, optimization, method, alpha, nr_perms, circular, min_seg)
}

#' StoppingBoundary
#' @description Calculates the early stopping boundary for permutation tests.
#' Permutation tests stop early if either more than \code{nr_perms*alpha} many
#' times the permuted data statistic exceeded the original statistic (no change point)
#' or if the stopping boundary is hit, i.e. the permuted data statistic exceeded
#' the original statistic not often enough so that is unlikely to be declined (change point).
#' @param nr_perms maximal number of permutations
#' @param alpha significance level
#' @param eta_star a control parameter for the probability of early stopping errors
#' @return vector containing \code{nr_perms*alpha} integers
#' @export
#'
StoppingBoundary <- function(nr_perms = 10000L, alpha = 0.01, eta_star = 0.0005) {
    .Call(`_OCBS_StoppingBoundary`, nr_perms, alpha, eta_star)
}

